{"id":"js/shader/vertex.glsl","dependencies":[{"name":"C:\\Apache24\\htdocs\\THREE-InfClouds\\package.json","includedInParent":true,"mtime":1655914457013}],"generated":{"js":"module.exports = \"#define GLSLIFY 1\\nuniform float time;\\nvarying vec2 vUv;\\nvarying vec3 vPosition;\\nvarying float vAlpha;\\nuniform vec2 pixels;\\nattribute vec3 translate;\\nattribute float aRotate;\\n\\nmat4 rotationMatrix(vec3 axis, float angle) {\\n    axis = normalize(axis);\\n    float s = sin(angle);\\n    float c = cos(angle);\\n    float oc = 1.0 - c;\\n    \\n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\\n                0.0,                                0.0,                                0.0,                                1.0);\\n}\\n\\nvec3 rotate(vec3 v, vec3 axis, float angle) {\\n\\tmat4 m = rotationMatrix(axis, angle);\\n\\treturn (m * vec4(v, 1.0)).xyz;\\n}\\n\\nfloat PI = 3.141592653589793238;\\nvoid main() {\\n  // create random on this value + 0.33 to change in sprite\\n  vUv = (uv - vec2(0.5))/3. + vec2(0.5 + 0.33, 0.5);\\n  \\n  float depth = 5.;\\n  // original uv before 6image file using cloud2 nice\\n  // vUv = uv;\\n  vec3 newpos = position;\\n  \\n  newpos = rotate(newpos, vec3(0., 0., 1.), aRotate);\\n  newpos += translate;\\n  newpos.z = -mod(newpos.z - time*0.01, 5.);\\n  // calculate distance\\n  vPosition = newpos;\\n  vAlpha = smoothstep(-5. +3.5, -4. +3.5, newpos.z);\\n  gl_Position = projectionMatrix * modelViewMatrix * vec4( newpos, 1.0 );\\n}\";"},"sourceMaps":{"js":{"mappings":[{"name":"module","generated":{"line":1,"column":0},"source":"js/shader/vertex.glsl","original":{"line":1,"column":0}},{"generated":{"line":1,"column":6},"source":"js/shader/vertex.glsl","original":{"line":1,"column":6}},{"name":"exports","generated":{"line":1,"column":7},"source":"js/shader/vertex.glsl","original":{"line":1,"column":7}},{"generated":{"line":1,"column":14},"source":"js/shader/vertex.glsl","original":{"line":1,"column":0}},{"generated":{"line":1,"column":17},"source":"js/shader/vertex.glsl","original":{"line":1,"column":15}},{"generated":{"line":1,"column":1611},"source":"js/shader/vertex.glsl","original":{"line":1,"column":0}}],"sources":{"js/shader/vertex.glsl":"module.exports=\"#define GLSLIFY 1\\nuniform float time;\\nvarying vec2 vUv;\\nvarying vec3 vPosition;\\nvarying float vAlpha;\\nuniform vec2 pixels;\\nattribute vec3 translate;\\nattribute float aRotate;\\n\\nmat4 rotationMatrix(vec3 axis, float angle) {\\n    axis = normalize(axis);\\n    float s = sin(angle);\\n    float c = cos(angle);\\n    float oc = 1.0 - c;\\n    \\n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\\n                0.0,                                0.0,                                0.0,                                1.0);\\n}\\n\\nvec3 rotate(vec3 v, vec3 axis, float angle) {\\n\\tmat4 m = rotationMatrix(axis, angle);\\n\\treturn (m * vec4(v, 1.0)).xyz;\\n}\\n\\nfloat PI = 3.141592653589793238;\\nvoid main() {\\n  // create random on this value + 0.33 to change in sprite\\n  vUv = (uv - vec2(0.5))/3. + vec2(0.5 + 0.33, 0.5);\\n  \\n  float depth = 5.;\\n  // original uv before 6image file using cloud2 nice\\n  // vUv = uv;\\n  vec3 newpos = position;\\n  \\n  newpos = rotate(newpos, vec3(0., 0., 1.), aRotate);\\n  newpos += translate;\\n  newpos.z = -mod(newpos.z - time*0.01, 5.);\\n  // calculate distance\\n  vPosition = newpos;\\n  vAlpha = smoothstep(-5. +3.5, -4. +3.5, newpos.z);\\n  gl_Position = projectionMatrix * modelViewMatrix * vec4( newpos, 1.0 );\\n}\";"},"lineCount":null}},"error":null,"hash":"3fc632dc6ee30741f419117c413df707","cacheData":{"env":{}}}